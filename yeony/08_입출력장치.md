# 08-1. 장치 컨트롤러와 장치 드라이버

## 장치 컨트롤러

- 입출력 장치가 까다로운 이유..!
  - 입출력장치의 종류가 너무 많기 때문에 규격화하기 어렵다
  - CPU와 메모리 데이터 전송률과는 달리 데이터 전송률이 느리기 때문에 CPU, 메모리와 입출력장치 간의 통신이 어렵다
- 위의 이유로 입출력장치를 컴퓨터에 직접 연결하지 않는다
  - 장치 컨트롤러를 사용한다
    - 입출력 제어기, 입출력 모듈 등,, 같은 말이다..
- 장치 컨트롤러가 하는 일
  - CPU와 입출력장치 간의 통신 중개
  - 오류 검출
  - 데이터 버퍼링
    - 데이터 전송률이 상이하기 때문에 버퍼에 데이터를 모았다가 내보내거나, 천천히 내보낸다
- 장치 컨트롤러의 구조
  - 데이터 레지스터
    - 데이터 버퍼링을 위해 버퍼 역할을 한다
    - 최근 주고받는 데이터가 많은 입출력장치에서 레지스터 대신 RAM을 사용한다
  - 상태 레지스터
    - 입출력장치의 현재 상태 정보를 저장한다
  - 제어 레지스터
    - 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장한다

## 장치 드라이버

- 장치 컨트롤러의 동작을 감지하고 제어하기 위해 장치 컨트롤러가 컴퓨터 내부와 정보를 주고 받을 수 있게 하는 프로그램
- 컴퓨터가 연결된 장치의 드라이버를 인식하고 실행한다

# 08-2. 다양한 입출력 방법

- 장치 컨트롤러와 CPU가 정보를 주고 받는 방법
  - 프로그램 입출력
  - 인터럽트 기반 입출력
  - DMA 입출력

## 프로그램 입출력

- 프로그램 명령어로 입출력장치를 제어
  - CPU가 입출력 장치의 장치 컨트롤러의 제어 레지스터에 명령을 보낸다
  - 장치 컨트롤러는 해당 입출력장치의 상태를 확인하고, 준비가 된 상태라면 상태 레지스터에 준비되었다고 한다
  - CPU는 장치 컨트롤러의 상태 레지스터를 지속적으로 확인하며 준비가 완료된 상태면 백업할 메모리의 정보를 데이터 레지스터에 쓴다
  - 보낸 명령이 끝날 때까지 위의 작업을 반복한다
- CPU가 입출력장치들의 주소는 어떻게 알까? 해당 레지스터들을 어떻게 알까?
  - 메모리 맵 입출력
  - 고립형 입출력

### 메모리 맵 입출력

- 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 공간을 하나의 주소 공간으로 본다
  - 메모리 주소 공간이 1024개면 반으로 나눠 관리 한다는 것!
  - 메모리 명령어와 입출력장치에 접근하는 명령어를 동일하게 사용한다

### 고립형 입출력

- 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법
  - 말 그대로 메모리 주소 공간을 따로 사용한다. 예를 들어,, 각각 1024개씩!
  - 메모리와 분리되어 있기 때문에 명령어도 다르게 되어야 한다

## 인터럽트 기반 입출력

- 인터럽트 요청은 CPU가 작업을 하는 도중 우선 순위가 높은 일을 요청받는 것이다
- 입출력장치에 의한 인터럽트는 장치 컨트롤러에 의해 발생한다
- CPU가 장치 컨트롤러에 일을 요청한 후 다시 장치 컨트롤러가 다했다!라는 신호를 CPU에 보내기 전까지는 CPU는 다른 일을 할 수 있다
  - 그러고나서 장치 컨트롤러가 다했다! 라고 하는 인터럽트 요청을 CPU에게 보내는 것

<aside>
💡 **폴링?**
인터럽트와 달리 CPU가 주기적으로 입출력장치의 상태 레지스터를 확인하는 것
CPU가 온전히 다른 일을 할 수 없다는 단점이 있다

</aside>

### 동시에 여러 인터럽트 요청이 온다면?

- 일단 인터럽트 순서대로 일을 처리한다
- 하지만 늘 순차적으로 진행할 수 없다면..? 우선순위가 높은 인터럽트가 가장 나중에 요청이 왔다면..?
  - CPU는 인터럽트도 우선순위를 매겨 일을 처리할 수 있다
- 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 `NMI(Non Maskable Interrupt)` 가 발생하면 우선순위에 맞는 일부터 처리한다

### PIC (Programmable Interrupt Controller)

- 다중 인터럽트를 처리하는 방법 중 PIC 하드웨어를 사용할 수도 있다
- 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 인터럽트 요청 우선순위를 판별하여 CPU에게 알려준다
- 섬세한 과정,,
  - PIC가 장치 컨트롤러에서 인터럽트 요청 신호를 받는다
  - PIC는 우선순위 판별 후, CPU에게 인터럽트 요청 신호를 보낸다
  - CPU는 PIC에게 인터럽트 확인 신호를 보낸다
  - PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보낸다
  - CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게되고, 해당 장치의 인터럽트 서비스 루틴을 실행한다
- 인터럽트 벡터에 인터럽트 요청의 주체 정보가 들어있다는 것!
- 여러개의 PIC가 존재하고 여러개의 PIC를 관리하는 하나의 PIC가 CPU에게 신호를 보내는 구조도 있다

## DMA 입출력

- 입출력장치와 메모리 사이에 전송되는 모든 데이터가 꼭 CPU를 거쳐야할까?
- 너무 바쁜 CPU의 부담을 덜어주기 위해 CPU를 거치지 않는 방법인 DMA 입출력이 등장!
- Direct Memory Access, DMA는 DMA 컨트롤러 하드웨어가 필요하다
- 섬세한 과정..!
  - CPU는 DMA 컨트롤러에 입출력장치의 주소, 연산, 메모리 주소 등 정보를 입출력작업을 명령한다
  - CPU에게 받은 정보를 이용해 DMA가 CPU 대신 장치 컨트롤러와 상호작용한다
    - 메모리가 필요하면 메모리에 직접 접근한다
  - 입출력 작업이 끝이나야 DMA가 CPU에게 작업이 끝났음을 알린다
- 하지만 시스템 버스는 공용자원인데,, CPU와 DMA 컨트롤러가 동시에 사용할 수 없다,,
  - CPU가 더 중요한 존재이기 때문에 DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을 때 이용하거나 CPU 허락을 받고 이용,,, 굉장히 갑을관계가 확실하다,,

### 입출력 버스

- DMA가 시스템 버스를 너무 자주 사용하면 CPU가 시스템 버스 사용을 자유롭게 할 수 없다..
- 그래서 DMA 컨트롤러와 장치 컨트롤러들을 `입출력 버스`라는 별도의 버스가 생겼다..!
- 대부분의 장치 컨트롤러는 입출력 버스와 연결되어 있다
