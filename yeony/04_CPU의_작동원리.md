# 04-1. ALU와 제어장치

## ALU : Arithmetic Logic Unit, 산수 논리 장치

- 직역한 것을 바탕으로 생각해보면 **계산**을 수행하는 장치이다.
- 계산을 하기 위해 필요한 것은?
  - `피연산자`
    - 레지스터에서 받는다
  - `제어신호`
    - 제어장치에서 받는다
- 계산 후, 내보낼 수 있는 것은?
  - 결과값
    - 다시 레지스터로 보낸다
  - 플래그
    - 결과값에 대한 부가적인 정보를 플래그 레지스터에게 보낸다
    - 결과값에 대한 부가적인 정보라함은?
      - 단순히 이진수를 통해서 양수인지 음수인지 판단하기 어렵기 때문에 이런 것들을 알려주기 위함. 결과값에 대한 특이사항.
    - 플래그 종류
      | 종류 | 의미 | 1이면 긍정
      0이면 부정 |
      | --- | --- | --- |
      | 부호 플래그 | 연산 결과의 양/음수 | |
      | 제로 플래그 | 0인지 아닌지 | |
      | 캐리 플래그 | 올림수나 빌림수의 발생 여부 | |
      | 오버플로우 플래그 | 오버플로우 발생 여부
      - 연산 결과를 담을 레지스터보다 큰 상황 | |
        | 인터럽트 플래그 | 인터럽트 가능 여부 | |
        | 슈퍼바이저 플래그 | 커널 모드인지, 사용자 모드인지 여부 | |

## 제어장치

- 명령어를 해석하여 제어 신호로 내보낸다
- 제어장치가 받는 것
  - 클럭, clock
    - 컴퓨터 내부의 시계, 타이머같은 존재
    - 시계가 똑딱똑딱 움직이는 박자에 맞춰서 부품들이 작동한다
  - 해석이 되지 않은 명령어
    - 명령어 레지스터에게 해석되지 않은 명령어를 받는다
  - 플래그 레지스터 속 플래그 값
    - 결과값에 대한 참고 사항을 받아야 정확한 해석이 가능하다
  - 제어 버스로 전달된 제어 신호
    - 외부에서 온 제어 신호를 받는다
- 제어장치가 보내는 것
  - CPU 내부와 외부로 제어 신호를 내보낸다
    - 외부로 보내는 것은 제어 버스를 통해 보내지

# 04-2. 레지스터

- CPU 내부 임시 저장 장치
- 레지스터에 오고가는 데이터를 알면 현재 CPU 내부에서 어떤 일이 일어나는지 알 수 있다

## 꼭 알아야하는 레지스터

- 많은 CPU들이 공통으로 포함하는 8가지의 레지스터가 있다
- 레지스터는 각 역할에 맞는 데이터를 저장한다

| 종류 | 역할 |
| ---- | ---- |

| 프로그램 카운터
(명령어 포인터) | 메모리에서 읽어 들일 명령어의 주소
프로그램의 순서를 관장하여 현재 읽어들어야 할 명령어 주소를 저장한다 |
| 명령어 레지스터 | 방금 메모리에서 읽은 명령어를 저장하는 곳 |
| 메모리 주소 레지스터 | 메모리가 읽어들이고자 하는 주소 값을 저장하는 곳
주소 버스로 내보낼 주소 값 |
| 메모리 버퍼 레지스터 | 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값을 저장하는 곳
데이터 버스로 주고 받을 값 |

- 프로그램 카운터는 꾸준히 증가하여 프로그램을 차례대로 실행하는데 기여한다
  - 프로그램이 차례대로 실행되지 않을 수 있다 → 실행 흐름이 끊길 수 있다
    - 특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행되었을 때
    - 인터럽트가 발생했을 때

| 종류                                   | 역할                                                    |
| -------------------------------------- | ------------------------------------------------------- |
| 범용 레지스터                          | 메모리 주소 레지스터와 메모리 버퍼 레지스터를 합친 개념 |
| 현재는 대부분 범용 레지스터를 사용한다 |
| 플래그 레지스터                        | 연산 결과와 CPU의 부가적인 정보를 저장하는 곳           |

## 특정 레지스터를 이용한 주소 지정 방식 1 : 스택 주소 지정 방식

- 스택과 스택 포인터를 이용한 주소 지정 방식
  - 스택 포인터?
    - 스택 중 가장 위에 있는 스택을 가리키는 레지스터
    - 가장 먼저 꺼내어질 레지스터를 가리킨다
    - 어디까지 채워져 있는지 알 수 있다
- 스택은 메모리 내부에 있다
  - 메모리 내부 스택으로 사용하겠다는 공간이 따로 있다
- 스택 포인터는 레지스터에 있다

## 특정 레지스터를 이용한 주소 지정 방식 2 : 변위 주소 지정 방식

- 명령어 내부에 오퍼랜드 외에 레지스터 필드가 있는 경우, 해당 레지스터의 값과 오퍼랜드가 가리키는 메모리 주소를 합하여 메모리 유효 주소를 알아낸다
- 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는 지에 따라 이런 방식은 두 가지로 나뉜다

### 상대 주소 지정 방식

- 오퍼랜드 + 프로그램 카운터
- 프로그램 카운터에서 오퍼랜드에서 받은 값만큼 이전, 또는 이후 메모리 주소로 이동
- 분기할 때 사용된다

### 베이스 레지스터 주소 지정 방식

- 오퍼랜드 + 베이스 레지스터
- 베이스 레지스터에서 받은 메모리 주소를 기준으로 오퍼랜드에서 받은 값만큼 떨어진 메모리 주소로 접근한다

# 04-3. 명령어 사이클과 인터럽트

<aside>
💡 interrupt? 방해하다

</aside>

- 명령어 사이클?
  - 하나의 명령어를 처리하는 정형화된 흐름
- 인터럽트?
  - 명령어 사이클이 끊어지는 상황

## 명령어 사이클

- 명령어들은 모두 명령어 사이클이 반복되며 실행된다
- `인출 사이클`
  - 메모리에 있는 명령어를 가져온다
  - CPU 내부에서 외부로 명령어를 가져오는 모든 단계를 합쳐서 생각한다
- `실행 사이클`
  - 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계
- 일반적으로 명령어는 인출 사이클과 실행 사이클을 계속 돌면서 명령어를 처리한다
- `간접 사이클`
  - 간접 주소 지정 방식 같은 경우 한번 더 추가적인 메모리 접근이 필요하기 때문에 이 단계를 간접 사이클이라고 한다

### 인터럽트

- CPU가 수행 중인 작업을 방해 받아 중단을 시킨다
  - 방해하는 신호를 받는다
- 굳이 수행 중인 작업이 있는 CPU를 중단 시키는 일이라면 분명 우선순위가 더 높은 일이 들어온 것이다
  - 이처럼 비정상적인 방해가 아닌, 꼭 필요한 방해이다
- 동기 인터럽트
  - CPU에 의해 발생하는 인터럽트
  - 프로그래밍 상 예외적인 상황이 발생했을 때 인터럽트 시킨다
- `비동기 인터럽트`
  - = `하드웨어 인터럽트`
  - 입출력장치에 의해 발생하는 인터럽트
  - 입출력장치의 입력에 의해 중단된다. 어떤 알림을 받고 중단된다
  - 입출력 작업 중에 계속적으로 입출력 장치의 작업이 끝났는지 CPU가 신경쓸 수 없기 때문에 입출력장치에 명령을 해놓고, 잠깐 CPU는 본인 일을 하다가 명령어를 수행한 입출력 장치가 알림을 보내면 CPU가 잠시 하던 일을 중단하고 입출력장치의 작업을 진행시켜준다
- **하드웨어 인터럽트 처리 순서**
  - 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다
    - “지금 껴들어도 되나요 CPU님?”
  - CPU의 실행 사이클이 끝나고 명령어 인출 전, 인터럽트 여부를 확인한다
  - CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받을 수 있는지 여부를 확인한다
    - 플래그 레지스터의 인터럽트 플래그의 값이 1이면 CPU는 인터럽트 받은 일을 수행한다. 하지만 0이면 본인의 중요한 일을 계속한다.
    - 하지만 하드웨어 고장이나 정전같은 일들은 아무리 플래그가 0이더라도 먼저 처리해야할 문제이다
  - 인터럽트를 받을 수 있다면 CPU는 지금까지 하던 일을 백업한다
  - CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다
    - 인터럽트 서비스 루틴 = 인터럽트 핸들러
      - 인터럽트를 처리하기 위한 프로그램
      - 각 인터럽트를 어떻게 처리하고, 작동할지에 대한 정보들로 이뤄진 프로그램
    - 인터럽트 벡터
      - 각 입출력장치의 인터럽트 서비스 루틴은 다를 것이고, 그것을 구별하기 위해 인터럽트 벡터가 존재한다
      - 어떤 서비스루틴을 실행해야할지 식별한다
      - 서비스 루틴의 시작점을 제공한다
  - 인터럽트 서비스 루틴을 끝내고 백업해준 작업을 복구하여 실행을 재개한다
    - 백업시에 현재 프로그램을 재개하기 위해 필요한 것들을 스택에 백업한다
    - 백업 후, 인터럽트로 들어갈 때, 프로그램 카운터 값을 해당 인터럽트로 변경하여 인터럽트 실행

### 예외의 종류

- 폴트
  - 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개
  - 갑자기 어떤 메모리에서 값을 가져와야할 때, CPU는 폴트를 발생시키고, 값을 가져오고 난 후 폴트가 발생한 명령어부터 다시 실행
- 트랩
  - 예외를 처리한 후 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개
    - 말그대로 트랩을 설치해서 지금 진행중인 명령어 실행을 잠시 중단시키고, 상태를 체크. 그리고 그 다음 명령어부터 다시 실행
  - 디버깅시 사용
- 중단
  - 심각한 오류를 발견했을 때
- 소프트웨어 인터럽트
  - 시스템 호출이 발생했을 때
