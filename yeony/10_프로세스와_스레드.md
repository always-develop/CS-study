# 10-1. 프로세스 개요

- `프로세스` = 실행 중인 프로그램

## 프로세스 직접 확인하기

- Window는 작업 관리자의 `프로세스 탭`에서 확인이 가능하다
- 유닉스 체계의 운영체제에서는 ps 명령어로 확인이 가능하다
  - Window를 제외한 대부분의 운영체제
- 포그라운드 프로세스, foreground process
  - 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- 백그라운드 프로세스, background process
  - 사용자가 보지 못하는 공간에서 실행되는 프로세스
- 사용자와 상호작용하지 않고 정해진 일만 하는 프로세스
  - 유닉스에서는 `데몬(daemon)`
  - 윈도우에서는 `서비스(service)`

## 프로세스 제어 블록

- 프로세스들은 돌아가며 CPU의 자원을 사용한다
  - 타이머 인터럽트가 발생하면 다음 프로세스에게 CPU를 넘긴다
- PCB, Process Control Block, 프로세스 제어 블록
  - 프로세스의 실행 순서를 관리하고, CPU 자원 배분 역할을 맡고 있다
    - 그러므로 프로세스를 식별하기 위한 정보가 저장된다
  - 메모리의 커널 영역에서 생성된다
  - 새로운 프로세스가 생성되었다 → 운영체제가 PCB를 생성했다
  - 프로세스가 종료되었다 → 운영체제가 해당 PCB를 폐기했다
- 아래는 PCB에 어떤 정보들이 담겨져있는지에 대한 내용이다

### 프로세스 ID, PID, Process ID

- 프로세스를 식별하기 위한 고유 번호
- 실행될 때마다 생성된다

### 레지스터 값

- 이전의 사용했던 작업들을 불러오기 위해 레지스터의 중간 값들을 모두 복원한다
- PCB 안에 담긴다

### 프로세스 상태

- 프로세스가 어떤 상태인지에 대한 정보
- 입출력장치를 위해 기다리는지, CPU 사용을 기다리는지, CPU를 사용 중인지 등..

### CPU 스케줄링 정보

- 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보

### 메모리 관리 정보

- 프로세스가 메모리의 어느 주소에 저장되어 있는지에 대한 정보
- 베이스 레지스터, 한계 레지스터 값에 대한 정보
- 페이지 테이블 정보

### 사용한 파일과 입출력장치 목록

- 특정 입출력장치를 사용한 적이 있는지에 대한 정보

## 문맥 교환

- 하나의 프로세스가 종료되고, 실행 순서가 넘어간 후의 과정은?
- 문맥, Context
  - 프로세스 수행을 재개하기 위해 기억해야할 정보
  - 위에서 언급된 PCB에 기록되는 정보라고 생각하면 쉽다
- 문맥 교환, Context switching
  - CPU에서 실행되는 PCB는 백업하고, 실행되어야할 새로운 PCB를 복구하는 과정
  - 문맥 교환이 빠를 수록 프로세스가 동시에 실행되는 것처럼 보이지만 자주 일어나면 오버헤드가 발생할 수 있다

## 프로세스 메모리 영역

- 메모리의 커널 영역에는 PCB가 생성된다
- 사용자 영역의 프로세스는 어떻게 배치될까?
  - 코드 영역
  - 데이터 영역
  - 힙 영역
  - 스택 영역

### 코드 영역

- = 텍스트 영역
- 기계어로 이루어진 명령어가 존재한다
- 읽기 전용 공간이다

### 데이터 영역

- 프로그램이 실행되는 동안 유지되어야 하는 데이터가 존재한다 → `전역 변수`

**위의 두 영역은 프로그램이 실행될 때, 크기가 변하지 않는 공간이기 때문에 `정적 할당 영역`이라고 부른다**

**반대의 경우는 `동적 할당 영역`이며 아래에 나오는 두 영역이다**

### 힙 영역

- 프로그래머가 직접 할당할 수 있는 영역
- 메모리 공간을 할당했으면 다시 꼭 `반환`해야한다
- 반환하지 않으면 할당한 메모리가 계속 존재하게 되어 메모리 낭비를 초래하며 이를 `메모리 누수(memory leak)`이라 부른다

### 스택 영역

- 데이터를 일시적으로 저장하는 공간 → `매개 변수`, `지역 변수`
- `PUSH`와 `POP`이 일어난다

**힙 영역은 메모리의 낮은 주소에서 높은 주소로 쌓이고, 스택 영역은 높은 주소에서 낮은 주소로 할당된다**

**메모리 주소가 겹칠 일을 방지하게 된다**

# 10-2. 프로세스 상태와 계층 구조

## 프로세스 상태

- 프로세스가 가질 수 있는 상태는 아래와 같다

### 생성 상태, new

- 프로세스가 생성 중인 상태
- 이제 메모리에 적재되어 PCB를 할당받은 상태
- 생성이 완료되면 CPU 할당을 기다린다

### 준비 상태, ready

- 당장 CPU를 할당받아 실행이 가능한 상태

<aside>
💡 **디스패치, dispatch?**
준비 상태인 프로세스가 실행 상태로 전환되는 것

</aside>

### 실행 상태, running

- CPU를 할당받아 실행 중인 상태
- 타이머 인터럽트가 발생하면 다시 준비 상태가 되었다가, 입출력장치를 기다리면 대기 상태가 된다

### 대기 상태, blocked

- 프로세스 실행 도중 입출력장치를 사용해야할 때 프로세스는 잠시 대기한다

### 종료 상태, terminated

- 프로세스가 종료된 상태
- PCB를 폐기한다

## 프로세스 계층 구조

- 프로세스가 실행 도중에 다른 프로세스를 생성하면?
  - 부모 프로세스와 자식 프로세스로 나뉠 수 있다
- 다른 프로세스이기 때문에 PID는 다르지만, 일부 운영체제는 자식 프로세스에 부모 프로세스의 PPID가 기록되기도 한다
- 이런 식으로 부모 프로세스 밑에 자식 프로세스들이 생겨나서 계층 구조를 이룰 수 있다 → `프로세스 계층 구조`
  - DOM같은,,
- 모든 프로세스의 가장 위에 있는 Root는 무엇일까?
  - 유닉스 : init
  - 리눅스 : systemd
  - macOS : launchd
  - Root 프로세스의 PID는 항상 1번이다..!

## 프로세스 생성 기법

- 부모 프로세스는 자식 프로세스를 어떻게 만들고, 자식 프로세스는 어떻게 자신의 코드를 실행할까?
- `fork`와 `exec`
  - fork
    - 부모 프로세스는 자신의 복사본으로 자식 프로세스를 생성한다
  - exec
    - 자식 프로세스는 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체한다
    - 자신의 메모리 공간을 새로운 프로그램으로 덮어 씌운다
    - 코드 영역과 데이터 영역은 실행할 프로그램의 내용으로 변경되고, 나머지 영역은 초기화된다
  - 두 방법은 `시스템 호출`이다
- 부모 프로세스의 fork가 일어나도 자식 프로세스가 exec를 호출하지 않는 경우는 두 프로세스를 함께 실행해야 할때이다

# 10-3. 스레드

- 스레드, thread는 프로세스를 구성하는 `실행 흐름의 단위`이다

## 프로세스와 스레드

- 단일 스레드 프로세스
  - 프로세스가 하나의 실행 흐름을 가지고, 한 번에 하나의 부분만 실행되는 프로세스
- 멀티 스레드 프로세스
  - 프로세스를 구성하는 여러 명령어를 동시에 실행하여 여러 일을 처리하는 프로세스
- 스레드는 프로세스 내에서 각자의 ID, 프로그램 카운터, 레지스터 값, 스택으로 구성된다
  - 하나의 프로세스 안에서 독립적인 스레드가 존재한다
  - 실행에 꼭 필요한 요소로 구성되어 있으며 나머지는 해당 프로세스의 자원을 공유한다

## 멀티프로세스와 멀티스레드

- 멀티프로세스
  - 여러 프로세스를 동시에 실행하는 것
- 멀티스레드
  - 여러 스레드로 프로세스를 동시에 실행하는 것
- 멀티프로세스와 멀티스레드의 가장 큰 차이점은 스레드는 프로세스의 자원을 공유한다는 것이다
  - 같은 작업이라도 멀티프로세스로 실행하면 같은 프로세스 환경이 메모리에 계속 적재되어 낭비가 될 수 있다
  - 하지만 멀티스레드는 같은 프로세스 환경을 공유하고 있기 때문에 프로세스 내에서 최소한의 정보들만 새로 생성한다
    - 코드, 데이터, 힙, 파일은 프로세스 내의 자원을 모두 공유한다
    - 이들은 서로 협력하여 움직일 수 있다는 큰 장점이 있다
    - 하지만 공유 자원에 문제가 있거나, 하나의 스레드에 문제가 발생하면 프로세스 전체의 문제로 될 수 있다는 단점이 있다
