# 14-1. 연속 메모리 할당

- 연속 메모리 할당 → 말 그대로 연속적으로 메모리를 할당한다는 것..!

## 스와핑

- 메모리에 적재된 프로세스들 중 현재 실행되지 않는 프로세스를 임시로 보조 기억 장치로 쫓아내고, 빈 공간에 다른 프로세스를 적재하는 것
  - 메모리에서 프로세스를 쫓아내는 것 → `스왑 아웃, swap-out`
  - 스왑 아웃으로 생긴 메모리의 빈 공간에 다른 프로세스를 적재하는 것 → `스왑 인, swap-in`
  - 이때 생긴 빈 공간 → `스왑 영역, swap space`
    - 스왑 영역의 크기와 사용 여부는 사용자가 설정할 수 있다

## 메모리 할당

- 메모리에 프로세스를 적재하기 위해서 빈 공간을 찾는데,, 빈 공간이 여러개라면 어디에 적재할까?

**최초 적합, first fit**
메모리의 빈 공간을 찾다가 가장 처음에 발견한 공간에 적재한다
검색 시간을 최소화할 수 있어 빠른 할당이 가능하다

**최적 적합, best fit**
프로세스가 적재될 수 있는 빈 공간을 모두 검색하고, 그 중에서 가장 작은 공간에 적재한다

**최악 적합, worst fit**
최적 적합과 반대로, 빈 공간을 모두 검색하고 그 중에서 가장 넓은 공간에 적재한다

## 외부 단편화

- 연속 메모리 할당은 `외부 단편화(external fragmentation)`이라는 문제를 가지고 있다
- 프로세스에 연속적으로 할당이 된 후, 각 프로세스들이 중간중간에 실행이 완료되어 빈 공간을 자잘하게 만들어 빈 공간보다 큰 프로세스를 받지 못하는 것
  - 결국 자잘한 빈 공간이 많이 생기고, 실제로 그 공간을 활용할 수 없으면 메모리 낭비로 이어진다!
- 메모리가 따로 떨어져있으면 총합이 30MB라도 30MB의 프로세스를 적재할 수 없다
- 이 문제를 해결하기 위해서 `압축(compaction)` 을 해야 한다
  - 빈 공간을 다 모아서 하나의 공간을 만드는 것이다!..
  - 이것의 단점은 공간을 옮길 때, 실행되던 프로세스가 중지되어야 하고, 작업 량이 많으면 오버헤드가 일어난다
- 요즘은 페이징기법을 사용하여 외부 단편화 현상을 예방한다

# 14-2. 페이징을 통한 가상 메모리 관리

- 메모리의 크기가 4GB이고, 일부는 운영체제가 사용한다면 프로세스가 4GB 이상인 것은 실행할 수없다
- 이런 물리적 메모리 크기는 한계가 있지만 요즘은 가상 메모리를 사용하여 실행하고 싶은 프로세스를 일부만 메모리만 적재할 수 있다

## 페이징이란

- 메모리를 일정한 논리적 단위로 자르고, 프로세스를 메모리 단위대로 할당한다
  - 예를 들어 메모리를 10MB 단위로 자르면 프로세스를 10MB단위로 잘라서 해당 메모리 조각들에 불연속적으로 적재한다
- 이러한 기법을 `페이징`이라고 한다
- 메모리의 일정한 논리적 단위 → 페이지, page
- 메모리의 물리 공간 → 프레임, frame
- 스와핑도 가능하며 페이징 기법에서 스와핑 개념은 스왑 인, 아웃이 아니고 `페이지-인(page-in)`, `페이지-아웃(page-out)`으로 부르기도 한다
- 프로세스를 페이지 크기에 맞춰 자른다면 프로세스 전체를 메모리에 적재할 필요없다!
  - 당장 프로세스를 실행할 때 필요한 부분만 페이지로 분리시켜 메모리에 적재하면 되고, 나머지는 보조 기억 장치에 그대로 둘 수도 있다
- 이런 방식으로 메모리의 크기가 프로세스의 크기보다 작아도 큰 프로세스를 실행할 수 있다

## 페이지 테이블

- 페이징을 이용해 메모리에 프로세스를 적재하면, CPU가 다음 페이지의 주소를 알기 어렵다.. (불연속적이기 때문)
- 이럴 때 CPU가 실행 중인 프로세스의 메모리 주소를 찾기 위해 페이지 테이블을 이용한다
  - CPU가 바라보는 논리주소는 페이지 테이블에 연속적으로 배치시킨다
- 페이지 테이블 베이스 레지스터, PTBR, Page Table Base Register
  - CPU내 존재하는 프로세스의 페이지 테이블의 주소를 가지고 있다
  - 페이지 테이블은 각 프로세스마다 존재한다
  - 프로세스는 페이지 테이블을 PCB에 가지고 있다
- CPU는 페이지 테이블을 참조할 수 있지만 페이지 테이블은 논리 주소이고, 메모리의 물리 주소인 프레임 주소도 알고 있어야 한다
- 페이지 테이블과 프레임을 두 가지를 알기 위해서는 메모리에 2번 접근해야한다
- TLB, Translation Lookaside Buffer을 이용해 페이지 테이블의 캐시를 둔다
  - 이미 접근한 테이블 주소는 이곳에 캐시로 남긴다
  - TLB 히트가 발생하면 CPU는 페이지 테이블에는 접근할 필요가 없지만 TLB 미스가 발생하면 페이지 테이블에 접근해야한다

## 페이징에서의 주소 변환

- 페이지나 프레임 내부는 여러 주소를 가지고 있는데,, 접근하기 위해서는 두 가지의 정보가 필요하다
  - 어떤 페이지 / 프레임에 접근하고 싶은지
  - 접근하려는 주소가 그 페이지 / 프레임에서 얼마나 떨어져 있는지
- 페이징 시스템의 논리 주소는 모두 `페이지 번호(page number)` 와 `변위(offset)`을 가지고 있다
- 페이지 번호는 진짜 페이지 번호!
- 변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼마나 떨어져 있는지 알 수 있다!
- 논리 주소(페이지 개념) → 물리 주소(프레임 개념) 로 변환된다

## 페이지 테이블 엔트리, PTE, Page Table Entry

- 페이지 테이블의 각각의 행동들을 말한다
- 페이지 테이블 엔트리에 담기는 정보는 페이지 번호와 프레임 번호 외에 더 있다..!

**유효비트(Valid bit)**
해당 페이지의 접근 가능 여부를 알려준다
페이지도 스왑이 가능하기 때문에 해당 페이지가 스왑영역(보조기억장치)에 있다면 유효비트가 0이고, 메모리에 적재되어 있다면 유효비트가 1이다
유효비트가 0인 페이지에 접근을 하면 페이지 폴트(page fault)라는 예외(exciption)이 발생한다
페이지 폴트는 인터럽트 과정과 유사하게 동작한다

**보호비트(Protection bit)**
페이지 보호 기능을 위해 존재한다
페이지 수정 권한에 대한 정보들이 있다 (읽기 전용 - Read, 수정 가능 여부 - Write, 실행 가능 여부 - eXecute)
해당 행동이 가능하면 1, 불가능하면 0으로 표시된다

**참조비트(Reference bit)**
CPU가 이 페이지에 접근한 적이 있는지의 여부를 말한다
참조한 적있으면 1, 없으면 0이다

**수정비트(Modified bit)**
해당 페이지의 수정 여부를 말한다
이것 또한 긍정이면 1, 부정이면 0이다
수정비트는 페이지가 메모리에서 사라질 때, 보조기억장치에 수정이 안되었으면 그대로 덮어씌우면 되지만, 수정이 되었으면 보조기억장치와 메모리에 있는 페이지가 서로 다른 값을 가지고 있기 때문에 변경된 값을 기록하는 작업이 있어야 한다

# 14-3. 페이지 교체와 프레임 할당

- 가상 메모리를 사용할 수 있지만 보조기억장치에 비해 메모리는 너무 한정적인 자원이다..!
- 그렇기 때문에 스왑을 어떻게 하느냐는 굉장히 중요한 작업이다

## 요구 페이징, demand paging

- 프로세스를 메모리에 적재할 때, 애초에 필요한 것만 적재한다
- 아무 페이지를 적재하지 않은 상태에서도 실행도 가능하다
  - 이 경우는 페이지 폴트가 계속 일어나게 되고, 페이지 폴트를 지속적으로 겪다보면 실행에 필요한 페이지가 모두 적재되었을 때부터 페이지 폴트 횟수가 줄어든다
  - 이를 `순수 요구 페이징(pure demand paging)`이라 한다

**페이지 교체**
메모리에 적재된 페이지 중 어느 페이지를 스왑해야할까.. ?
스왑은 페이지 교체 알고리즘에 의해 결정된다

## 페이지 교체 알고리즘

- 페이지 폴트가 가장 적게 일어나는 알고리즘이 좋은 알고리즘이라고 불린다 → 여튼 페이지 폴트가 없으면 속도가 빠르니까!
- 페이지 폴트 횟수와 페이지 참조열에 대한 개념을 알아야 이 알고리즘을 이해할 수 있다

**페이지 참조열(page reference string)**
CPU가 참조하는 페이지 중 연속된 페이지를 생략한 페이지 열 (불연속 적인 페이지 열)
연속된 페이지는 페이지 폴트를 일으키지 않기 때문에 중요하지 않고, 연속되지 않았을 때 페이지 폴트가 일어나기 때문에 중요한 개념이다

### 알고리즘 종류

**FIFO 페이지 교체 알고리즘**
가장 먼저 올라온 페이지부터 쫓는다… 오래 있었음 좀 나가~
지속적으로 필요한 페이지가 오래되었다고 내쫓으면 다시 불러 들여야하기 때문에 그렇지 좋은 방법은 아니다
여기서 변형된 2차 기회 페이지 교체 알고리즘도 있는데.. 이는 참조비트의 유무에 따라 페이지들에게 내쫓기전 기회를 한 번 더준다..!

**최적 페이지 교체 알고리즘**
CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다
나가야하는건.. 오래된 페이지가 아니고, 참조 횟수가 적은 페이지인 것이다
페이지 폴트율이 정말 낮은 알고리즘이지만 실제 구현이 어렵기 때문에(프로세스가 미래에 어떤 메모리를 참조하게 될지까지 예측하기 어려움) 이 알고리즘이 페이지 폴트의 하한선으로 정한다

**LRU 페이지 교체 알고리즘, Least Recently Used Page Replacement Algorithm**
오랫 동안 사용되지 않은 페이지를 교체한다

## 스래싱과 프레임 할당

- 페이지 폴트 발생은 단순 알고리즘의 문제가 아닐 수 있다
- 프로세스가 사용할 프레임 수가 적어도 충분히 일어날 수 있다 → 근본적인 페이지 폴트 발생 이유라고 함
- 당연히 프레임 수가 적으면 프로세스 실행을 하면 할수록 계속 내쫓는 일이 많아지니까…
- 프로세스 실행보다 페이징에 시간을 더 오래 사용하여 성능이 저하되는 문제를 `스래싱(thrasing)`이라고 한다
- 멀티 프로그래밍의 정도
  - 메모리에서 동시에 실행되는 프로세스 수
- 결론적으로는 물리 메모리가 작으면 CPU의 성능과 관계없이 컴퓨터의 성능이 좋지 않다
- 운영체제는 프로세스들이 실행될 때 사용할 적절한 프레임의 개수를 알고 있어야 하고, 할당해주어야 한다
- 프레임할당 방식
  - 균등 할당, equal allocation
    - 각 프로세스마다 같은 프레임을 할당
  - 비례 할당, proportional allocation
    - 프로세스의 크기에 따라 프레임을 할당
  - 이 두 가지의 할당 방법은 프로세스의 실행 과정은 고려하지 않고 있기 때문에 `정적 할당 방식` 으로 분류된다
  - 생각보다 실행했더니 프로세스 크기만큼 프레임을 사용하지 않을 수 있다..! 그리고 아래는 `동적 할당 방식`이다
    - 작업 집합 모델, working set model
      - 프로세스 실행 과정에서 배분할 프레임을 결정하는 것
    - 페이지 폴트 빈도, PFF, Page Fault Frequency
      - CPU의 참조 지역성의 원리를 이용하여 CPU가 참조한 페이지 개수만큼 프레임을 할당한다
      - 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합인 `작업 집합`을 이용해 프레임을 할당하는 방식이다
      - 결론적으로 페이지 폴트율이 너무 낮거나 높지 않은 범위 내에서 프레임을 할당하는 방식이다
