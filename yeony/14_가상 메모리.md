# 14-1. 연속 메모리 할당

- 연속 메모리 할당 → 말 그대로 연속적으로 메모리를 할당한다는 것..!

## 스와핑

- 메모리에 적재된 프로세스들 중 현재 실행되지 않는 프로세스를 임시로 보조 기억 장치로 쫓아내고, 빈 공간에 다른 프로세스를 적재하는 것
  - 메모리에서 프로세스를 쫓아내는 것 → `스왑 아웃, swap-out`
  - 스왑 아웃으로 생긴 메모리의 빈 공간에 다른 프로세스를 적재하는 것 → `스왑 인, swap-in`
  - 이때 생긴 빈 공간 → `스왑 영역, swap space`
    - 스왑 영역의 크기와 사용 여부는 사용자가 설정할 수 있다

## 메모리 할당

- 메모리에 프로세스를 적재하기 위해서 빈 공간을 찾는데,, 빈 공간이 여러개라면 어디에 적재할까?

**최초 적합, first fit**
메모리의 빈 공간을 찾다가 가장 처음에 발견한 공간에 적재한다
검색 시간을 최소화할 수 있어 빠른 할당이 가능하다

**최적 적합, best fit**
프로세스가 적재될 수 있는 빈 공간을 모두 검색하고, 그 중에서 가장 작은 공간에 적재한다

**최악 적합, worst fit**
최적 적합과 반대로, 빈 공간을 모두 검색하고 그 중에서 가장 넓은 공간에 적재한다

## 외부 단편화

- 연속 메모리 할당은 `외부 단편화(external fragmentation)`이라는 문제를 가지고 있다
- 프로세스에 연속적으로 할당이 된 후, 각 프로세스들이 중간중간에 실행이 완료되어 빈 공간을 자잘하게 만들어 빈 공간보다 큰 프로세스를 받지 못하는 것
  - 결국 자잘한 빈 공간이 많이 생기고, 실제로 그 공간을 활용할 수 없으면 메모리 낭비로 이어진다!
- 메모리가 따로 떨어져있으면 총합이 30MB라도 30MB의 프로세스를 적재할 수 없다
- 이 문제를 해결하기 위해서 `압축(compaction)` 을 해야 한다
  - 빈 공간을 다 모아서 하나의 공간을 만드는 것이다!..
  - 이것의 단점은 공간을 옮길 때, 실행되던 프로세스가 중지되어야 하고, 작업 량이 많으면 오버헤드가 일어난다
- 요즘은 페이징기법을 사용하여 외부 단편화 현상을 예방한다

# 14-2. 페이징을 통한 가상 메모리 관리

- 메모리의 크기가 4GB이고, 일부는 운영체제가 사용한다면 프로세스가 4GB 이상인 것은 실행할 수없다
- 이런 물리적 메모리 크기는 한계가 있지만 요즘은 가상 메모리를 사용하여 실행하고 싶은 프로세스를 일부만 메모리만 적재할 수 있다

## 페이징이란

- 메모리를 일정한 논리적 단위로 자르고, 프로세스를 메모리 단위대로 할당한다
  - 예를 들어 메모리를 10MB 단위로 자르면 프로세스를 10MB단위로 잘라서 해당 메모리 조각들에 불연속적으로 적재한다
- 이러한 기법을 `페이징`이라고 한다
- 메모리의 일정한 논리적 단위 → 페이지, page
- 메모리의 물리 공간 → 프레임, frame
- 스와핑도 가능하며 페이징 기법에서 스와핑 개념은 스왑 인, 아웃이 아니고 `페이지-인(page-in)`, `페이지-아웃(page-out)`으로 부르기도 한다
- 프로세스를 페이지 크기에 맞춰 자른다면 프로세스 전체를 메모리에 적재할 필요없다!
  - 당장 프로세스를 실행할 때 필요한 부분만 페이지로 분리시켜 메모리에 적재하면 되고, 나머지는 보조 기억 장치에 그대로 둘 수도 있다
- 이런 방식으로 메모리의 크기가 프로세스의 크기보다 작아도 큰 프로세스를 실행할 수 있다

## 페이지 테이블

- 페이징을 이용해 메모리에 프로세스를 적재하면, CPU가 다음 페이지의 주소를 알기 어렵다.. (불연속적이기 때문)
- 이럴 때 CPU가 실행 중인 프로세스의 메모리 주소를 찾기 위해 페이지 테이블을 이용한다
  - CPU가 바라보는 논리주소는 페이지 테이블에 연속적으로 배치시킨다
- 페이지 테이블 베이스 레지스터, PTBR, Page Table Base Register
  - CPU내 존재하는 프로세스의 페이지 테이블의 주소를 가지고 있다
  - 페이지 테이블은 각 프로세스마다 존재한다
  - 프로세스는 페이지 테이블을 PCB에 가지고 있다
- CPU는 페이지 테이블을 참조할 수 있지만 페이지 테이블은 논리 주소이고, 메모리의 물리 주소인 프레임 주소도 알고 있어야 한다
- 페이지 테이블과 프레임을 두 가지를 알기 위해서는 메모리에 2번 접근해야한다
- TLB, Translation Lookaside Buffer을 이용해 페이지 테이블의 캐시를 둔다
  - 이미 접근한 테이블 주소는 이곳에 캐시로 남긴다
  - TLB 히트가 발생하면 CPU는 페이지 테이블에는 접근할 필요가 없지만 TLB 미스가 발생하면 페이지 테이블에 접근해야한다
