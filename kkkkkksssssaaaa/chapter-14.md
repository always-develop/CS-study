# 14장. 가상 메모리

# [CS] 👽 혼자 공부하는 컴퓨터구조+운영체제

---

## 14장. 가상 메모리

### 14-1. 연속 메모리 할당

- 메모리 내에 프로세스들이 연속적으로 배치될 수 있도록 메모리 공간을 할당하는 것을 `연속 메모리 할당` 이라고 한다
- `스와핑(Swapping)` 이란
  - 메모리에 적재된 프로세스 중에서는 당장 실행하지 않는 프로세스도 존재한다
  - 이런 프로세스들이 메모리를 점유하고 있는 것은 낭비이기 때문에, 일부 데이터들을 보조기억장치로 옮긴다
    - 이 때 메모리에서 옮겨진 데이터들이 저장되는 보조기억장치의 영역을 `스왑 영역(Swap space)` 이라고 한다
    - 스왑 영역으로 옮겨지는 것을 `스왑 아웃(Swap-Out)`, 다시 메인 메모리로 옮겨가는 것을 `스왑 인(Swap-In)` 이라고 한다
  - 이렇게 생긴 메모리 공간에 다른 프로세스들을 적재할 수 있게 된다
  - 이러한 메모리 관리 방식을 스와핑이라고 한다
- 스와핑 덕분에 RAM 크기보다 더 큰 프로그램들을 동시에 실행할 수 있다
- 프로세스를 메모리에 배치하는 할당 방식은 크게 세 가지 방식이 존재한다
  - `최초 적합(First fit)`
    - 운영체제가 메모리 내 빈 공간을 찾다가 프로세스를 배치할 수 있는 공간을 발견하면 바로 배치하는 방식
    - 메모리 탐색을 최소화할 수 있다는 장점이 있어, 빠른 프로세스 할당이 가능하다
  - `최적 적합(Best fit)`
    - 운영체제가 메모리의 모든 공간을 탐색하여 가장 최적의 장소에 프로세스를 배치하는 방식
    - 다소 시간이 소요될 수 있겠다
  - `최악 적합(Worst fit)`
    - 최적 적합과 같이 모든 공간을 탐색 후 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다
- 연속 메모리 할당은 메모리를 효율적으로 사용하는 방법은 아니라고 한다
  - `외부 단편화(External fragmentation)` 이라는 문제를 내포하고 있다
  - 프로세스를 할당할 수 없을 만큼의 메모리 공간이 생겨나, 메모리 공간이 낭비되는 현상을 뜻한다
  - 스와핑에도 외부 단편화는 발생한다
- 외부 단편화를 해결하기 위한 대표적인 방안으로는 메모리를 `압축(Compaction)` 하는 방법이 있다
  - 메모리 조각 모음이다
  - 흩어져있는 프로세스들을 한데 모아 연속적인 형태로 재배치하는 것이다
  - 다만, 이 과정에서 시스템은 하던 일을 모두 중단해야하고 메모리의 내용들을 그대로 다른 공간으로 옮기는 비용이 많이 들기 때문에, 최적의 압축 방법을 찾기 어렵다….

### 14-2. 페이징을 통한 가상 메모리 관리

- `가상 메모리(Virtual Memory)` 는 실행 하려는 프로그램의 일부만 메모리에 적재하고 다른 데이터들은 보조기억장치에 저장하게 하는 기술
  - 즉, 프로세스가 사용하는 논리적인 주소 공간을 뜻하며, RAM+보조기억장치로 이루어져 있다
  - 컴퓨터의 물리적인 RAM 크기보다 더 큰 프로그램을 실행할 수 있다
  - 프로세스는 데이터가 RAM 에 적재 되는지, 보조기억장치에 적재 되는지 알 수 없다
- 가상 메모리 관리 기법은 크게 `페이징` 과 `세그멘테이션` 두 가지가 있는데 대부분의 현대 운영체제들은 페이징을 사용한다
- 프로세스의 논리 주소 공간을 `페이지` 라는 단위로 나누어, 메모리의 물리적인 공간인 `프레임` 에 할당하는 가상 메모리 관리 기법이다
- 페이지로 나뉜 데이터들을 메모리에 할당한다면 낭비되는 공간이 없이 활용할 수 있게 될 것이다
  - 프로세스가 종료되어 빈 공간이 생겨도 메모리에 적재될 데이터의 크기는 모든 프로세스가 동일하기 때문
- 여기서도 스와핑을 사용할 수 있다
  - 프로세스 전체가 아닌, 페이지 단위로 스왑한다
  - 이 때, 페이지가 메인 메모리로 올라가는 것을 `페이지 인(Page-In)`, 메인 메모리에 있던 페이지가 보조기억장치로 이동하는 것을 `페이지 아웃(Page-Out)` 이라고 한다
- 페이징 기법에서는 논리 주소 공간과 물리 주소 공간을 매핑하기 위해 `페이지 테이블(Page Table)` 이라는 자료구조를 사용한다
  - 페이지 테이블 덕에 프로세스 입장에서는 연속된 메모리 주소를 할당받은 것 처럼 보이게 할 수 있다
  - 페이지 테이블은 모든 프로세스가 가지고 있으며, 메모리에도 적재되어 있다
  - `페이지 테이블 베이스 레지스터(Page Table Base Register, PTBR)` 이라는 레지스터는 각 프로세스의 페이지 테이블이 적재된 주소를 저장하고 있다고 한다
  - 이것 저것 저장하는 데이터들이 많기 때문에, `TLB(Translation Lookaside Buffer)` 라는 페이지 테이블 캐시 메모리도 있다고 한다
    - CPU 가 페이지 테이블에 접근하는 비용을 줄여준다
    - 캐시이기 때문에, CPU 가 TLB 를 참조하는 경우는 TLB 히트, 참조하지 못하는 경우를 TLB 미스라고 한다
- 페이징은 만능은 아니며…. `내부 단편화(Internal Fragmentation)` 문제를 야기할 수 있다
  - 프로세스를 페이지 단위로 자를 때, 페이지에 맞게 잘라지지 않는 프로세스도 있다
  - 이 때 페이지 크기와 실제 데이터 크기만큼의 차이가 생겨 메모리가 낭비되는 것을 뜻한다
  - 페이지 크기를 적절하게 설정하는 것도 중요하다..
- 페이징 시스템에서는 모든 논리주소가 `페이지 번호(Page Number)`와 `변위(Offset)` 테이블로 이루어져 있다
  - 이 때 페이지 테이블에 저장되는 데이터에 열 정보를 `페이지 테이블 엔트리(Page Table Entry, PTE)` 라고 부른다
  - 페이지 테이블 엔트리에는 페이지 번호, 변위 말고도 해당 페이지의 정보를 알려주는 비트 정보로 구성되어 있다
    - `유효 비트(Valid Bit)` 해당 페이지가 메모리에 적재 되었는지 여부를 알려준다
      - 유효 비트가 0인 페이지에 접근하려면 `페이지 폴트(Page Fault)` 예외가 발생한다고 한다
    - `보호 비트(Protection Bit)` 는 페이지에 대한 읽기/수정/실행 여부를 알려준다
    - `참조 비트(Reference Bit)` 는 해당 페이지에 CPU 가 접근 했는지 여부를 알려준다
    - `수정 비트(Modified Bit)` or `더티 비트(Dirty bit)` 는 해당 페이지에 쓰기 동작이 있었는지에 대한 여부를 알려준다
- 페이지 테이블을 여러개 두는 방식도 있다..

### 14-3. 페이지 교체와 프레임 할당

- `요구 페이징(Demand Paging)` 이란
  - 프로세스를 메모리에 적재할 때 필요한 페이지만을 메모리에 적재하는 기법
  - 페이지 폴트가 발생하는 페이지가 존재할 때 마다 메모리에 적재하는 방식이라고 한다
  - 물론, 아무런 페이지도 메모리에 적재하지 않고 실행할 수도 있다
    - 이 경우 당연히 첫 명령어를 실행하는 그 순간부터 페이지 폴트가 발생한다
    - 이러한 방법을 `순수 요구 페이징(Pure Demand Paging)` 이라고 한다
- 요구 페이징이 안정적으로 작동하려면 `페이지 교체` 와 `프레임 할당` 문제를 해결해야 한다…
- `페이지 교체` 란 메모리에 적재된 페이지를 보조기억장치로 내보내는것(==Page Out)이며, 이 방법을 `페이지 교체 알고리즘` 이라고 한다
- `페이지 교체 알고리즘` 은 페이지 폴트를 가작 적게 일으키는 것을 좋은 알고리즘으로 평가한다
  - 그만큼 CPU 가 접근하는 페이지의 히트율이 좋다는 뜻을 의미하는 것이기도 하다
- 페이지 교체 알고리즘을 제대로 이해하기 위해서는 `페이지 폴트 횟수` 를 알 수 있어야 한다
  - `페이지 참조열(Page Reference String)` 을 통해 할 수 있다
  - CPU 가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지 열을 의미한다고 한다
- `FIFO 페이지 교체 알고리즘`
  - 가장 먼저 메모리에 올라온 페이지부터 아웃시키는 방법
  - 프로그램 초기에 실행되다가 사용되지 않을 페이지가 많다면 효율적이겠지만, 프로그램이 살아있는 동안 계속 실행 되어야할 페이지가 많다면 아주 효율이 좋지 않다
- `최적 페이지 교체 알고리즘(Optimal Page Replacement Algorithm)`
  - 앞으로의 사용 빈도가 가장 낮을 것이라 예상되는 페이지를 교체하는 방식
  - 다만, 이를 예측하기 어려워서 실제로 구현하기에는 어렵다
- `LRU 페이지 교체 알고리즘(Least Recently Used Page Replacement Algorithm)`
  - 최근 사용되지 않은 페이지는 앞으로도 사용되지 않을 것이라는 전제에, 최근 사용되지 않은 오래된 페이지를 아웃시키는 방식
- 만약 프레임이 부족하다면 페이지 폴트가 자주 발생할 것이다
  - 용량이 부족하여 페이지 교체가 많이 실행되는 경우를 뜻한다
  - 프로세스가 실제로 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 `스래싱(Trashing)` 이라고 한다
  - 하지만, 근본적인 원인은 프로세스마다 필요한 최소한의 프레임 수가 부장되어 있지 않기 때문이다
    - 프로세스의 크기에 따라 프레임 수를 적절하게 지정하는 것이 중요..
- 메모리에서 동시에 실행되는 프로세스의 수를 `멀티프로그래밍의 정도(Degree of Multi Programming)` 라고 한다
  - 이 정도가 높다면 메모리에 많은 프로세스가 동시에 실행 중이라는 것을 뜻한다
  - 정도가 높다고 해서 CPU 이용률이 높아지는 것은 아니다
    - 어느 정도는 CPU 이용률이 높아지겠지만, 필요 이상으로 높아진다면 스래싱이 일어날 가능성도 높아진다
    - 여튼 적절하게 물리 메모리 공간이 확보되어 있는 것이 유리하다
    - 이 때문에 물리 메모리가 너무 작으면 컴퓨터 성능이 좋아지지 않는 것이다 🫢
- 프로세스마다 프레임 수를 균등하게 할당하는 방식인 `균등 할당(Equal Allocation)` 방식이 있으며, 프로세스의 크기마다 프레임을 할당하는 `비례 할당(Proportional Allocaton)` 방식이 있다
  - 다만, 실제로 프로세스가 동작할 때 많은 프레임이 필요하지 않을 수도 있다
  - 균등 할당과 비례 할당은 런타임을 고려하지 않은 방식이라는 점에서 `정적 할당` 방식이라고도 한다
- 프로세스를 실행하는 과정에서 배분할 프레임을 결정할 수도 있다
  - `작업 집합 모델(Working Set Model)` 이라는 방식과 `페이지 폴트 빈도(Page-Fault Frequency)` 를 사용하는 방식이 있다
- `작업 집합 모델(Working Set Model)` 방식
  - 참조 지역성의 원리를 이용하여, 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지한다고 한다
  - 즉, 참조한 페이지만큼의 프레임 수만 할당하는 방식이다
  - 이 때 참조한 페이지 집합을 `작업 집합(Working Set)` 이라고 한다
- `페이지 폴트 빈도(Page-Fault Frequency)` 방식
  - 페이지 폴트율의 상한선과 하한선을 정해, 해당 범위 내에서만 프레임을 할당하는 방식이라고 한다
