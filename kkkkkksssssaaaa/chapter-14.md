# 14장. 가상 메모리

# [CS] 👽 혼자 공부하는 컴퓨터구조+운영체제

---

## 14장. 가상 메모리

### 14-1. 연속 메모리 할당

- 메모리 내에 프로세스들이 연속적으로 배치될 수 있도록 메모리 공간을 할당하는 것을 `연속 메모리 할당` 이라고 한다
- `스와핑(Swapping)` 이란
  - 메모리에 적재된 프로세스 중에서는 당장 실행하지 않는 프로세스도 존재한다
  - 이런 프로세스들이 메모리를 점유하고 있는 것은 낭비이기 때문에, 일부 데이터들을 보조기억장치로 옮긴다
    - 이 때 메모리에서 옮겨진 데이터들이 저장되는 보조기억장치의 영역을 `스왑 영역(Swap space)` 이라고 한다
    - 스왑 영역으로 옮겨지는 것을 `스왑 아웃(Swap-Out)`, 다시 메인 메모리로 옮겨가는 것을 `스왑 인(Swap-In)` 이라고 한다
  - 이렇게 생긴 메모리 공간에 다른 프로세스들을 적재할 수 있게 된다
  - 이러한 메모리 관리 방식을 스와핑이라고 한다
- 스와핑 덕분에 RAM 크기보다 더 큰 프로그램을 실행할 수 있게 된다!
- 프로세스를 메모리에 배치하는 할당 방식은 크게 세 가지 방식이 존재한다
  - `최초 적합(First fit)`
    - 운영체제가 메모리 내 빈 공간을 찾다가 프로세스를 배치할 수 있는 공간을 발견하면 바로 배치하는 방식
    - 메모리 탐색을 최소화할 수 있다는 장점이 있어, 빠른 프로세스 할당이 가능하다
  - `최적 적합(Best fit)`
    - 운영체제가 메모리의 모든 공간을 탐색하여 가장 최적의 장소에 프로세스를 배치하는 방식
    - 다소 시간이 소요될 수 있겠다
  - `최악 적합(Worst fit)`
    - 최적 적합과 같이 모든 공간을 탐색 후 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다
- 연속 메모리 할당은 메모리를 효율적으로 사용하는 방법은 아니라고 한다
  - `외부 단편화(External fragmentation)` 이라는 문제를 내포하고 있다
  - 프로세스를 할당할 수 없을 만큼의 메모리 공간이 생겨나, 메모리 공간이 낭비되는 현상을 뜻한다
  - 스와핑에도 외부 단편화는 발생한다
- 외부 단편화를 해결하기 위한 대표적인 방안으로는 메모리를 `압축(Compaction)` 하는 방법이 있다
  - 메모리 조각 모음이다
  - 흩어져있는 프로세스들을 한데 모아 연속적인 형태로 재배치하는 것이다
  - 다만, 이 과정에서 시스템은 하던 일을 모두 중단해야하고 메모리의 내용들을 그대로 다른 공간으로 옮기는 비용이 많이 들기 때문에, 최적의 압축 방법을 찾기 어렵다….

### 14-2. 페이징을 통한 가상 메모리 관리

- `가상 메모리(Virtual Memory)` 는 실행 하려는 프로그램의 일부만 메모리에 적재하고 다른 데이터들은 보조기억장치에 저장하게 하는 기술
  - 즉, 프로세스가 사용하는 논리적인 주소 공간을 뜻하며, RAM+보조기억장치로 이루어져 있다
  - 컴퓨터의 물리적인 RAM 크기보다 더 큰 프로그램을 실행할 수 있다
  - 프로세스는 데이터가 RAM 에 적재 되는지, 보조기억장치에 적재 되는지 알 수 없다
- 가상 메모리 관리 기법은 크게 `페이징` 과 `세그멘테이션` 두 가지가 있는데 대부분의 현대 운영체제들은 페이징을 사용한다
- 프로세스의 논리 주소 공간을 `페이지` 라는 단위로 나누어, 메모리의 물리적인 공간인 `프레임` 에 할당하는 가상 메모리 관리 기법이다
- 페이지로 나뉜 데이터들을 메모리에 할당한다면 낭비되는 공간이 없이 활용할 수 있게 될 것이다
  - 프로세스가 종료되어 빈 공간이 생겨도 메모리에 적재될 데이터의 크기는 모든 프로세스가 동일하기 때문
- 여기서도 스와핑을 사용할 수 있다
  - 프로세스 전체가 아닌, 페이지 단위로 스왑한다
  - 이 때, 페이지가 메인 메모리로 올라가는 것을 `페이지 인(Page-In)`, 메인 메모리에 있던 페이지가 보조기억장치로 이동하는 것을 `페이지 아웃(Page-Out)` 이라고 한다
- 페이징 기법에서는 논리 주소 공간과 물리 주소 공간을 매핑하기 위해 `페이지 테이블(Page Table)` 이라는 자료구조를 사용한다
  - 페이지 테이블 덕에 프로세스 입장에서는 연속된 메모리 주소를 할당받은 것 처럼 보이게 할 수 있다
  - 페이지 테이블은 모든 프로세스가 가지고 있으며, 메모리에도 적재되어 있다
  - `페이지 테이블 베이스 레지스터(Page Table Base Register, PTBR)` 이라는 레지스터는 각 프로세스의 페이지 테이블이 적재된 주소를 저장하고 있다고 한다
  - 이것 저것 저장하는 데이터들이 많기 때문에, `TLB(Translation Lookaside Buffer)` 라는 페이지 테이블 캐시 메모리도 있다고 한다
    - CPU 가 페이지 테이블에 접근하는 비용을 줄여준다
    - 캐시이기 때문에, CPU 가 TLB 를 참조하는 경우는 TLB 히트, 참조하지 못하는 경우를 TLB 미스라고 한다
- 페이징은 만능은 아니며…. `내부 단편화(Internal Fragmentation)` 문제를 야기할 수 있다
  - 프로세스를 페이지 단위로 자를 때, 페이지에 맞게 잘라지지 않는 프로세스도 있다
  - 이 때 페이지 크기와 실제 데이터 크기만큼의 차이가 생겨 메모리가 낭비되는 것을 뜻한다
  - 페이지 크기를 적절하게 설정하는 것도 중요하다..
- 페이징 시스템에서는 모든 논리주소가 `페이지 번호(Page Number)`와 `변위(Offset)` 테이블로 이루어져 있다
  - 이 때 페이지 테이블에 저장되는 데이터에 열 정보를 `페이지 테이블 엔트리(Page Table Entry, PTE)` 라고 부른다
  - 페이지 테이블 엔트리에는 페이지 번호, 변위 말고도 해당 페이지의 정보를 알려주는 비트 정보로 구성되어 있다
    - `유효 비트(Valid Bit)` 해당 페이지가 메모리에 적재 되었는지 여부를 알려준다
    - `보호 비트(Protection Bit)` 는 페이지에 대한 읽기/수정/실행 여부를 알려준다
    - `참조 비트(Reference Bit)` 는 해당 페이지에 CPU 가 접근 했는지 여부를 알려준다
    - `수정 비트(Modified Bit)` or `더티 비트(Dirty bit)` 는 해당 페이지에 쓰기 동작이 있었는지에 대한 여부를 알려준다
- 페이지 테이블을 여러개 두는 방식도 있다..
  -
