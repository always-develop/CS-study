# 04. ALU 와 제어장치

# [CS] 👽 혼자 공부하는 컴퓨터구조+운영체제

---

## 04. ALU 와 제어장치

### 04-1. ALU 와 제어장치

- 산술 논리 연산 장치(Arithmetic Logic Unit, ALU)는 이름 그대로 계산을 담당하는 CPU 의 부품이다
  - 계산을 하기 위해선… 피연산자와 수행할 연산이 필요하다
  - 1 + 2 라는 계산식이 존재할 때
  - 1, 2는 피연산자, + 는 연산
- ALU 는 레지스터를 통해 `피연산자` 를 받아들이며, 제어장치로부터 수행할 연산을 알려주는 `제어 신호` 를 받는다
- ALU 의 연산 결과는 문자가 될 수도 있고, 숫자가 될 수도 있고, 메모리 주소가 될 수 있다
  - 연산이 끝난 데이터는 메모리에 바로 저장되는 것이 아니라, 일단 레지스터에 저장된다
  - 만약 메모리에 바로 저장하게 된다면 CPU to 메모리의 접근 속도가 느리기 때문에, 우리가 사용하는 애플리케이션도 느려질 수 있다
  - 그리고 ALU 는 `플래그` 도 내보낸다!
- 플래그란.. ALU 의 연산 결과의 부가 정보라고 할 수 있다
  - 예를 들어, 양수/음수를 판단하기 위한 플래그라던가..
- ALU 가 내보내는 대표적인 플래그
  - 부호
    - 연산 결과가 음수인지, 양수인지 나타내기 위한 플래그
  - 제로
    - 연산 결과가 0인지 여부를 나타내기 위한 플래그
  - 캐리
    - 연산 결과, 올림수나 빌림수가 발생했는지 나타내기 위한 플래그
  - 오버플로우
    - 연산 결과 데이터가 레지스터의 크기보다 큰지를 나타내기 위한 플래그
  - 인터럽트
    - 인터럽트가 가능한지를 나타내기 위한 플래그
  - 슈퍼바이저
    - 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타내기 위한 플래그
- `제어장치` 는 제어 신호를 내보낸다!
  - 제어 신호는 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호라고 할 수 있다
  - 가장 정교하게 설계된 부품이란다
- 제어장치가 받는 정보
  - 클럭 신호
    - 클럭이란, 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위라고 한다
    - 컴퓨터 부품들은 클럭이라는 박자에 맞춰 동작한다고 한다
      - 그렇다고 해서 박자마다 동작하는 것은 아니다
    - 간단하게 말해서 동작 주파수라고 한단다
      - 1초 동안 파장이 한 번 움직이는 시간…….
      - 이 시간동안 처리하는 데이터 양에 따라 CPU 속도가 달라진다고 한당
      - 오버 클럭 → CPU 의 동작 주파수를 올려 처리 속도를 높이는 것이었당
      - [참고 링크](https://library.gabia.com/contents/infrahosting/1227/)
  - 해석해야 할 명령어
    - CPU 가 해석할 명령어는 `명령어 레지스터` 라는 특별한 레지스터에 저장된당
    - 제어장치는 이 레지스터로부터 해석할 명령어를 받아 해석하고 제어 신호를 발생시킨다
  - 플래그 레지스터 속의 플래그 값
  - 제어 버스로 전달된 제어 신호
    - CPU 외부에 전달하는 제어 신호와 내부로 전달하는 제어 신호가 있다!
    - CPU 외부에 전달하는 신호는 제어 버스를 통해 전달된다

### 04-2. 레지스터

- `프로그램 카운터(Program Counter,  PC)`
  - 명령어 포인터(Instruction Pointer) 라고 한다
  - 메모리에서 읽어들일 명령어의 주소를 저장하는 레지스터
  - 명령어가 처리될 때 마다 프로그램 카운터가 증가하며, 계속해서 다음 명령어를 읽어들일 준비를 한다고 한다
    - 명령어 중 특정 메모리 주소로 실행 흐름을 이동하는 명령어를 만나게 된다면 프로그램 카운터의 주소가 완전히 다른 주소로 변경될 수 있다
- `명령어 레지스터(Instruction Register, IR)`
  - 메모리에서 읽어들인 명령어를 저장하는 레지스터
  - 제어 장치는 이 레지스터의 명령어를 받아 해석한 뒤 제어 신호를 내보낸다!
- `메모리 주소 레지스터(Memory Address Register, MAR)`
  - CPU 가 데이터를 읽거나 쓰려는 메모리 주소를 저장하는 레지스터
  - 주소 버스에서 오가는 데이터가 이 레지스터를 거친다고 한다
- `메모리 버퍼 레지스터(Memory Buffer Register, MBR)`
  - 혹은 `메모리 데이터 레지스터(Memory Data Register)` 라고도 한다
  - 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터
  - 데이터 버스로 오가는 데이터가 이 레지스터를 거친다
- 플래그 레지스터
- 범용 레지스터
  - 말 그대로 범용적으로 쓰이는 레지스터라고 한다
- 스택 포인터
  - `스택 주소 지정 방식` 이라는 주소 지정 방식에 사용되는 레지스터라고 한다!
    - `스택 주소 지정 방식` 이란, 스택과 스택 포인터를 이용한 주소 지정 방식이라고 한다
    - 즉, 마지막에 적재한 데이터의 위치를 저장하는 레지스터라고 한다
    - 그냥 메모리 내에 스택 형식의 데이터를 쌓을 수 있는 공간이 있고, 이를 `스택 영역` 이라고 부른다고 한다
- 베이스 레지스터
  - 주소 지정에 사용될 수 있는 특별한 레지스터라고 한다
- `변위 주소 지정 방식` 이란
  - 오퍼랜드의 필드 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻는 주소 지정 방식이라고 한다 😱
  - 그래서 변위 주소 지정 방식을 사용하는 명령어는 연산 코드/레지스터/오퍼랜드 의 세 가지 영역으로 구분되어 있다고 한다
  - 이 때, 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라서 `상대 주소 지정 방식` 과 `베이스 레지스터 주소 지정 방식` 으로 나뉜다고 한당
    - `상대 주소 지정 방식` 이란..
      - 오퍼랜드 + 프로그램 카운터 값을 더하여 유효 주소를 얻는 방식
      - 예를 들어 프로그램 카운터가 5번지를 가르키고 있고, 오퍼랜드에 -2 가 들어있다면…. 3번지로 접근한다
      - 이는 마치 `if` 문처럼 분기에 따라 코드를 실행해야 할 때 사용한다
    - `베이스 레지스터 주소 지정 방식` 이란
      - 오퍼랜드 + 베이스 레지스터 값을 더하여 유효 주소를 얻는 방식이다
      - 베이스 레지스터란, 기준 주소라는 것을 뜻하는데… 명령이 시작되는 시작 번지를 기억하고 있는 레지스터라고 한다

### 04-3. 명령어 사이클과 인터럽트

- 하나의 명령어를 처리하는 과정을 `명령어 사이클` 이라고 한다
  - 메모리에 있는 명령어를 CPU 로 가지고 오는 단계를 `인출 사이클(fetch cycle)` 이라고 한다
  - CPU 로 가져온 명령어를 실행하는 단계를 `실행 사이클(Execution Cycle)` 이라고 한다
  - 간접 주소 지정 방식의 명령어인 경우, 유효 주소로의 접근을 통해 명령에 사용할 데이터를 가져와야 하는데, 이 단계를 `간접 사이 클(Indirect Cycle)` 이라고 한다
- 명령을 처리하는 과정 중 흐름이 끊겨지는 상황이 발생하는데, 이를 `인터럽트` 라고 한다
  - 방해하다, 중단시키다 라는 의미의 영어단어.
  - 인터럽트는 동기 인터럽트와 비동기 인터럽트로 나뉜다
    - 동기 인터럽트란
      - CPU 에 의해 발생하는 인터럽트
      - 보통 `예외` 라고 한다
      - CPU 가 명령어를 수행하다가 예상치 못한 상황에 마주쳤을때… 발생한다고 한다
    - 비동기 인터럽트란
      - 주로 입출력장치에 의해 발생한다
        - 그래서 하드웨어 인터럽트라고도 한다
      - 예를 들어.. 프린터의 완료 알림이라던가, 키보드, 마우스의 입력 알림이라던가..
      - 입출력장치의 명령을 언제까지나 기다릴 수 없기 때문에, 인터럽트가 발생하기 전 까지 CPU 는 다른 명령을 처리하게 된다
- 하드웨어 인터럽트의 처리 순서
  - 입출력장치가 CPU 에게 `인터럽트 요청 신호` 를 보낸다
    - 지금 끼어들어도 되냐는 신호
  - CPU 는 실행 사이클이 끝나고 명령어를 인출하기 전, 항상 인터럽트 여부를 확인한다
  - CPU 는 인터럽트 요청을 확인하고 `인터럽트 플래그` 를 통해 현재 인터럽트를 받아들일 수 있는지 확인한다
    - 아주아주 중요한 작업을 실행하고 있을 경우 인터럽트 플래그가 불가능으로 설정되어 있다!
    - 이 경우 인터럽트가 있어도 무시한다고 한다
    - 다만, 우선순위가 높은 인터럽트라면… 무시할 수 없다고 한다!
  - 인터럽트를 받아들일 수 있다면 CPU 는 지금까지의 작업을 백업한다
  - CPU 는 `인터럽트 벡터` 를 참조하여 `인터럽트 서비스 루틴` 을 실행한다
    - `인터럽트 서비스 루틴(Interrupt Service Routine, ISR)` 이란 인터럽트 처리를 위한 프로그램이다
      - 인터럽트 핸들러 라고도 한다
      - 예를 들어… 마우스가 인터럽트 요청을 보냈을 때에는 요래오래 작동한다 같은 정보가 있다고 한다
    - 이러한 서비스 루틴을 구분하기 위해, `인터럽트 벡터` 라는 식별 정보를 활용한다!
    - 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있다고 한다…
  - 인터럽트 서비스 루틴이 종료되면 백업한 작업을 복구하여 재개한다
    - 그렇다면, 인터럽트가 발생하기 전 까지 저장한 데이터는 어디에 있는가? 스택 영역에 백업해둔다고 한다

### 좀 더 알아보기

- `예외` 가 발생하면 CPU 는 하던 일을 다 멈추고 예외를 처리한다고 한다
  - 예외를 모두 처리하고 다시 원래의 작업을 재개하게 될 때, 예외가 발생한 명령어부터 실행할지, 그 다음 명령어부터 실행할지에 따라 폴트와 트랩으로 나뉜다
- `폴트(fault)` 란 예외가 발생한 명령어부터 실행을 재개하는 예외
- `트랩(trap)` 이란 예외가 발생한 그 다음 명령어부터 실행을 재개하는 예외
  - 디버깅 할 때 사용한당
- `중단(abort)` 이란 CPU 가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 만났을 때 발생한다고 한다
- `소프트웨어 인터럽트` 라는 것도 있다!
