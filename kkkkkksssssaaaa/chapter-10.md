# 10장. 프로세스와 스레드

# [CS] 👽 혼자 공부하는 컴퓨터구조+운영체제

---

## 10장. 프로세스와 스레드

### 10-1. 프로세스 개요

- 사용자가 보는 앞에서 실행되는 프로세스를 `포그라운드 프로세스`, 반대로 사용자가 보지 않는 곳에서 실행되는 프로세스를 `백그라운드 프로세스` 라고 한다
  - 백그라운드 프로세스 중, 사용자와 상호작용하지 않고 정해진 일만 수행하는 프로세스를 유닉스와 윈도우에서는 각각 `데몬` 과 `서비스` 라고 명한다
- 운영체제는 컴퓨터 자원을 프로세스에게 할당한다
  - 운영체제가 프로세스에게 CPU를 효율적으로 할당하기 위하여 `프로세스 제어 블록(Process Control Block, PCB)` 라는 것을 이용한다
  - PCB는 프로세스와 관련된 정보를 저장하는 특별한 자료구조이며, 프로세스를 식별하기 위해 꼭 필요한 정보들이 저장된다
    - 프로세스 ID(Process ID, PID)
      - PID 는 프로세스마다 부여된 고유한 식별자이다
    - 레지스터 값
      - 프로세스의 프로그램 카운터를 비롯한 레지스터의 값들을 저장한다
      - 다시 프로세스가 CPU를 할당받아 실행될 때 저장된 레지스터들의 값과 프로그램 카운터 정보를 불러오게 되어 중단된 작업 내용을 이어서 수행할 수 있다
    - 프로세스 상태
      - 프로세스가 현재 CPU를 점유하고 있는 상태인지, 입출력장치를 사용하기 위해 기다리고 있는 상태인지.. 등 프로세스의 상태를 저장하고 있다
    - CPU 스케줄링 정보
    - 메모리 관리 정보
      - 프로세스가 사용하는 베이스 레지스터, 한계 레지스터 값과 같은 정보들이 저장된다
    - 사용한 파일과 입출력장치 목록
- PCB 는 커널 영역에 생성된다
- CPU 를 할당받은 프로세스가 변경되는 것을 `문맥 교환(Context Switching)` 이라고 한다
  - 문맥이란, 프로세스가 이전까지 실행했던 내용들을 다시 실행할 수 있도록 하기 위한 정보들을 말한다
  - 결국 PCB에 저장되는 정보들은 프로세스의 문맥이다
  - 문맥 교환에는 컴퓨터 자원이 많이 소모된다
- 프로세스에게 할당된 메모리 중, 사용자 영역에 저장되는 정보들은 아래의 네 가지 영역으로 다시 나뉘어 불린다
  - 코드 영역(or 텍스트 영역)
    - CPU 가 읽을 수 있는 명령어들이 저장되는 영역
    - 그렇기 때문에 프로세스가 생성되고 난 후 코드 영역의 데이터는 읽기 전용 공간이 된다
  - 데이터 영역
    - 프로세스가 실행되는 동안 유지되는 데이터들이 저장된다
      - 즉, 프로세스와 라이프사이클이 거의 동일한 데이터들이 저장된다
    - 보통 전역 변수들이 저장되는 공간이다
    - 코드 영역과 데이터 영역은 프로세스가 만들어짐과 동시에 크기가 결정된다
      - 그런 의미로 두 영역을 `정적 할당 영역` 이라고 한다
      - 반대로, 런타임에서 영역의 크기가 변동되는 힙 영역과 스택 영역은 `동적 할당 영역` 이라고 한다
  - 힙 영역
    - 주로 인스턴스가 저장된다
    - 즉, 프로그래머가 직접 할당할 수 있는 저장공간이다
    - 이 영역에 할당된 데이터들을 안쓰게 된다면 운영체제에게 반납해야한다
      - 만약, 할당된 공간을 반납하지 않게 되면 쓰레기 데이터로 남게 되어 `메모리 누수(Memory Leak)` 가 발생하게 된다
      - 메모리 낭비라는 뜻이다
    - 가비지 콜렉터가 청소하는 영역이 이 힙 영역이다
  - 스택 영역
    - 잠시 쓰이는 데이터들이 저장된다
      - 보통 함수-메서드와 주기가 같다
      - 즉, 함수-메서드가 종료되면 스택 영역의 데이터도 사라진다
      - 가장 휘발성이 높은 영역이다
    - 주로 매개변수, 지역변수가 저장된다

### 10-2. 프로세스 상태와 계층 구조

- 한 개의 CPU(core)에서는 하나의 프로세스만 실행된다
  - 프로세스가 엄청나게 문맥 교환을 수행하기 때문에 여러 작업을 수행하는 것 처럼 보일 뿐
- 프로세스의 상태는 운영체제마다 조금은 다르지만 대체적으로 아래와 같은 상태가 있다
  - 생성
    - 이제 막 메모리에 적재되어 PCB를 할당받은 상태
  - 준비
    - `생성` 단계의 다음 단계로, CPU 를 할당받기 전의 상태
    - 준비 상태에서 `실행` 상태로 넘어가는 작업을 `디스패치` 라고 한다
  - 실행
    - CPU를 할당받은 상태
    - 일정 시간동안만 실행 상태로 존재하며, 할당된 시간을 모두 사용하게 된다면 타이머 인터럽트가 발생하며 `준비` 상태로 돌아간다
  - 대기
    - 실행 상태에 있던 프로세스가 입출력장치의 작업을 기다리고 있다면, 해당 작업이 끝날 때 까지는 대기 상태에 있는다
    - 입출력장치의 작업이 끝나면 입출력 완료 인터럽트가 발생하며 `준비` 상태로 돌아간다
    - 입출력장치 뿐만 아니라 특정한 이벤트를 기다릴 때에도 대기 상태에 빠진다
      - 이 상태의 대부분이 입출력장치에 인한 것일 뿐…
  - 종료
    - 프로세스가 종료되며 운영체제가 PCB 와 프로세스에게 할당한 메모리를 정리한다
- 프로세스는 시스템 호출을 통해 다른 프로세스를 생성할 수 있는데, 이 때 호출한 프로세서를 `부모 프로세스`, 호출된 프로세스를 `자식 프로세스` 라고 한다
  - 엄연히 프로세스가 다르기 때문에 PID 도 다르게 생성된다
  - 일부 운영체제의 경우 자식 프로세스이면 부모의 프로세스 ID(Parent Process ID, PPID)를 별도로 저장하고 있기도 한다
  - 이 구조는 계층 구조로 표현될 수 있다
  - 모든 프로세스는 최초의 프로세서로부터 생성된다
- 부모 프로세스를 통해 생성된 자식 프로세스들은 `복제(Fork)` 와 `옷 갈아입기(exec)` 로 실행된다고 한다
  - 부모 프로세스가 `fork` 를 통해 자신의 복사본을 자식 프로세스로 생성하고
    - 복사본이기 때문에 부모 프로세스의 자원 정보나 사용한 파일과 입출력장치 목록 등등이 자식 프로세스에게 상속된다고 한다
    - 하지만 PID 값이나 저장된 메모리 위치는 다르다고 한다
  - 복사본은 `exec` 을 통해 자신의 메모리 공간을 다른 프로그램으로 교체한다
    - 코드 영역과 데이터 영역의 값들이 부모 프로세스의 프로그램이 아닌 다른 프로그램의 것으로 교체되며, 나머지 영역들은 초기화 된다고 한다
    - `exec` 를 수행하지 않는 자식 프로세스도 있는데, 이 경우는 부모 프로세스와 자식 프로세스가 같은 코드를 병행하여 실행하는 프로세스가 된다

### 10-3. 스레드

- 스레드는 프로세스의 실행 단위를 뜻한다
  - 하나의 프로세스는 여러 개의 스레드를 가질 수 있다
- 스레드라는 개념이 도입되어 프로세스가 여러 작업을 동시에 실행할 수 있게 되었다
  - 스레드도 고유의 식별자를 가지며, 프로그램 카운터 값을 비롯한 레지스터 값, 스택으로 구성된다고 한다
  - 모든 스레드가 프로그램 카운터 값과 별도의 스택 영역을 가지고 있기 때문에 스레드마다 다른 코드를 실행할 수 있게 되었으며, 이 외의 프로세스 자원들은 모두 공유한다
- 리눅스는 프로세스와 스레드를 굳이 나누지 않는다
  - 어차피 프로세스와 스레드 모두 실행의 문맥이라는 점에서 동등하기 때문에, `태스크(task)` 라는 이름으로 통일해서 부른다고 한다
- 스레드가 공유하는 자원
  - 코드 영역
  - 데이터 영역
  - 힙 영역
    - 동시성 이슈의 근원지..
  - 파일
- 스레드가 공유하지 않는 자원
  - 레지스터
  - 스택 영역
  - 프로그램 카운터
