# 05. CPU 성능 향상 기법

# [CS] 👽 혼자 공부하는 컴퓨터구조+운영체제

---

## 05. CPU 성능 향상 기법

### 05-1. 빠른 CPU 를 위한 설계 기법

- `클럭`
  - 클럭 신호가 빨라지면 CPU 를 비롯한 다른 컴퓨터 부품들이 그만큼 빠른 박자에 맞추어 일하게 된다
  - 그래서 클럭 속도는 CPU 속도 단위로 간주되기도 한다
  - Hz 단위로 측정하며 이는 1초에 클럭이 몇 번 반복되는지 나타낸다고 한다
  - 클럭 속도는 매번 일정하게 유지되지는 않고 처리할 작업에 따라 유연하게 움직인다고 한다
  - 최대 클럭 속도를 강제로 끌어 올리는 것을 `오버클럭킹` 이라고 한다
- `코어` 와 `멀티코어`
  - 많은 사람들이 알고 있는 CPU 의 정의는 현대의 CPU 에선 `코어` 에 해당하는 정의이다
    - 코어가 명령어를 실행하며, ALU, 레지스터, 제어장치 등등은 모두 CPU 라는 거대한 부품에 속하는 것이 아닌, 큰 CPU 를 이루는 개별 코어에 존재하는 것이다
    - 즉, 코어마다 각각의 ALU, 레지스터, 제어장치가 존재한당
  - 코어가 1개 이상이면 멀티코어라고 한당
  - 싱글코어 CPU 의 클럭이 높은 것 보다, 당연히 클럭이 낮은 멀티코어가 훨씬 성능이 좋다
    - 당연히 많다고 무조건 빠른건 아니고, 코어에게 작업 분배를 잘 해야 한당
- `스레드` 와 `멀티스레드`
  - 스레드는… 실행 흐름의 단위이다
    - 엄밀히 말하면~ CPU 와 프로그래밍의 스레드는 다르다고 한다
    - CPU 의 스레드는 `하드웨어적 스레드` 이고, 프로그래밍의 스레드는 `소프트웨어적 스레드` 이다
  - 하드웨어적 스레드는..
    - 하나의 코어가 동시에 처리하는 명령어의 단위이다
    - 예를 들어, 8코어 16스레드의 CPU 라면.. 8개의 코어가 각각 두 개의 하드웨어 스레드를 처리한다는 뜻이라고 할 수 있다
    - 소프트웨어 스레드보다 갯수가 훨씬 적다..
    - `논리 프로세서` 라는 이름으로 부르기도 한다
  - 소프트웨어적 스레드는..
    - 하나의 프로그램에서 독립적으로 실행되는 단위!
    - 하드웨어 스레드보다 훨씬 많다
      - 1코어 1스레드의 CPU 도 소프트웨어 스레드를 여러 개 실행 할 수 있다
- `멀티스레드 프로세서`
  - 핵심은 레지스터이다
  - 한 개의 명령어를 처리하기 위한 레지스터의 세트가 여러 벌 있는 것이당
  - 소프트웨어 입장에서 보는 멀티스레드 프로세서는, 코어가 몇 개던 간에 멀티스레드 프로세서의 개수 == CPU 의 개수로 본다고 한다

### 05-2. 명령어 병렬 처리 기법

- 클럭 단위로 나눠보는 명령어의 처리 과정
  1. 명령어 인출(Instruction Fetch)
  2. 명령어 해석(Instruction Decode)
  3. 명령어 실행(Execute Instruction)
  4. 결과 저장(Write Back)
  - 명령어 처리 과정은 전공서에 따라 다르게 나올 수도 있다고 한다
- `명령어 파이프라인`
  - 단계가 겹치지 않는다면, CPU 는 각 단계를 동시에 실행할 수 있다고 한다
  - 예를 들어, 한 명령어를 인출하는 과정이라면, 다른 명령어를 해석하거나 실행할 수도 있다
  - 이렇게 명령어를 공장 생산 라인처럼 동시에 처리하는 기법을 `명령어 파이프라이닝` 이라고 한다
  - 파이프라이닝이 불러올 수 있는 위험에 대해서는 `파이프라인 위험` 이라고 표현하는데, 파이프라인 위험의 유형은 아래와 같다
    - 데이터 위험
      - 명령어간 데이터 의존성에 의해 발생한다
      - 명령어에 선후관계가 존재할 때, 즉 1번 명령어가 완료되어야 2번 명령어를 실행할 수 있는 경우이다..
      - 1번 명령어가 완료 되지 않았지만, 결과를 R1 레지스터에 저장해야하는 상황에서 2번 명령어가 실행되어 R1 레지스터를 참조해야 한다면 원치 않는 값을 얻을 수 있다
    - 제어 위험
      - 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발상하는 위험
      - 이러한 변화에 대응하기 위해 프로그램이 어디로 분기할지 미리 예측하여 해당 주소를 인출하는 기술도 있다고 한다
    - 구조적 위험
      - 명령어들을 겹쳐서 실행하는 과정에서 서로 다른 명령어가 동시에 CPU 자원을 사용하려 할 때 발생하는 문제
      - `자원 위험` 이라고도 한다
- `슈퍼스칼라`
  - CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조라고 한다
  - 명령어 파이프라인 기법은 생산 공장을 한 개만 두는거고, 슈퍼스칼라는 여러 개 두는 것과 같다고 한다
  - 여전히 파이프라인 위험이 발생할 수 있다
- `비순차적 명령어 처리`
  - `Out-of-order execution, OoOE` 라고도 한당
  - 오늘날의 CPU 성능 향상에 크게 기여한 기법이라고 한다
  - 명령어의 합법적인 새치기 방법이라고 한다
  - 명령어 파이프라인의 데이터 위험 현상을 방지하기 위해, 순서에 상관 없이 처리할 수 있는 명령어들을 우선적으로 처리한다면, 더 효율적일 것이다….
  - 이처럼 명령어를 순차적으로 처리하지 않고, 순서를 바꿔도 무방한 명령어를 먼저 처리하여 파이프라인이 멈추는 것을 방지하는 기법을 비순차적 명령어 처리라고 한다

### 05-3. CISC 와 RISC

- 명령어 처리 기법인 슈퍼스칼라나 파이프라이닝을 잘 적용하려면, 명령어가 파이프라인 기법에 최적화 되어 있어야 한다
- 명령어의 기본적인 구조는 비슷하지만, 세세한 생김새는 CPU 마다 차이가 있다
  - CPU 가 이해할 수 있는 명령어들의 모음을 `명령어 집합(Instruction set)` 또는 `명령어 집합 구조(Instruction Set Architecture, ISA)` 라고 한다
    - CPU 나 컴파일러에 따라 어셈블리어가 달라질 수도 있다고 한다
- ISA 에 다라 CPU 의 레지스터 종류와 개수, 메모리 관리 방법 등이 달라질 수 있다
- `CISC(Complex Instruction Set Computer)`
  - x86, x86-64 가 대표적인 CISC 기반의 ISA 라고 한다
  - 가변 길이 명령어를 활용한다고 한다
    - 상대적으로 적은 수의 명령어로 프로그램을 실행할 수 있다고 한다
    - == 프로그램 자체에 대한 크기가 작다
    - 때문에 메모리를 최대한 아끼며 개발해야했던 시절에 인기가 높았다고 한당
  - 하지만 복잡하고 다양한 기능을 제공하는 탓에, 명령어의 크기와 실행되기까지의 시간이 일정하지 않는다는 치명적인 단점이 있다고 한다
  - 이는 파이프라이닝 기법을 구현하는데에도 치명적인 단점으로 존재한다
    - 가장 이상적인 명령어는 클럭이 동일해야 하나, 클럭이 동일하지 않다면 효율적인 파이프라인 형태를 만들 수 없게 되기 때문이다
  - 게다가 CISC 가 제공하는 다양한 명령어들의 사용 빈도가 낮다고 한다
- `RISC(Reduced Instruction Set Computer)`
  - ARM 이 대표적인 RISC 기반의 ISA 라고 한다
  - CISC 에 비해서는 제공되는 명령어 개수는 적다
  - 되도록 짧고 규격화된 명령어, 1클럭 내외로 실행되는 명령어를 지향한다
  - 즉, `고정 길이 명령어` 를 활용한다
    - 다시말해, 파이프라인 기법에 최적화 되어 있다
    - CISC 에 대비하여 프로그램의 크기가 크다고 한다
  - 메모리에 직접 접근하는 명령어를 `load` 와 `store` 로 단순화하는데, 이 때문에 RISC 를 load-store 구조라고 한다고 한당
    - 메모리 접근을 최소화하는 대신 레지스터를 적극적으로 사용한다고 한다
