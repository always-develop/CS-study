# 03. 명령어

# [CS] 👽 혼자 공부하는 컴퓨터구조+운영체제

---

## 03. 명령어

### 03-1. 소스 코드와 명령어

- 프로그래밍 언어와 컴퓨터가 이해하는 명령어는 다르다!
  - 프로그래밍 언어로 작성한 소스 코드가 0101의 명령어로 변환된다!
- 일반적으로 사용하는 자바, 파이썬과 같은 프로그래밍 언어를 고급 언어, 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 저급 언어라고 한다
  - 저급 언어에는 어셈블리어와 기계어가 있다
  - 기계어가 바로 0과 1의 명령어 비트로 이루어진 명령어이다
- 이진수 명령어의 가독성을 위해 십육진수를 이용했으나, 이 마저도 사람이 이해하기 힘들어서 어셈블리어가 나왔다
- 게임 개발자도 어셈블리어를 많이 이용한다고 한다 👀
- 어셈블리어를 알면 좋은 이유는…
  - 컴퓨터가 프로그램을 어떤 과정으로 실행하는지에 대해 알 수 있다
- 소스 코드 전체가 저급 언어로 변환되는 과정을 `컴파일`, 컴파일을 수행하는 도구를 `컴파일러` 라고 한다
  - 이 때 저급 언어로 변환된 코드를 `목적 코드` 라고 한다
  - ❓ 목적 코드와 바이트 코드
    - 목적 코드는 OS 가 읽고 실행할 수 있는 코드로써, 주로 C 언어를 배울 때 자주 등장하는 녀석.
      - C 언어 계열의 컴파일 결과물은 목적 코드라고 한당
      - 다만, 목적 코드는 CPU 에 종속적이기 때문에, 컴파일한 결과물을 다른 CPU 에서는 해석하지 못하여 재컴파일 해야한다
        - 즉, 실행 환경에 종속적이다
    - 그에 반해 자바나 자바스크립트의 컴파일 결과물은 바이트 코드인데, 자바의 바이트 코드는 OS 가 아닌 JVM 이라는 자바 실행 환경이 실행할 수 있는 코드를 의미
      - JVM 의 바이트 코드는 JVM 환경에서 언제든 수행 가능하기 때문에, 실행 환경에 제약이 없다
      - Write Once, Run Everywhere
    - 즉,
      - 목적 코드 == OS 가 읽을 수 있는 코드
      - 바이트 코드 == 특정 프로그램이 읽을 수 있는 코드(≠OS)
    - 자바의 경우, 바이트 코드는 JVM 에 의해 기계어로 번역된다
- 실행할 소스 코드를 한 줄씩 변환해주는 도구를 `인터프리터` 라고 한다
- 컴파일 언어와 인터프리터 언어는 요즘 시대엔 구분하기 힘드며, 그저 기계어 번역 방식엔 두 가지가 존재한다 정도로만 이해하면 좋다
- 목적 코드로 이루어진 파일을 목적 파일이라고 하며, 실행 코드로 이루어진 파일을 실행 파일이라고 한다
  - 실행 파일을 만들기 위해 목적 코드를 `링킹` 이라는 작업을 거쳐야 한다
  - 링킹은 여러 목적 코드를 모아 연결해주는 작업이다

### 03-2. 명령어의 구조

- 명령어는 `연산 코드` 와 `오퍼랜드` 로 구성되어 있다
  - e.g. `더해라 | 100과, 120을` 이라는 명령어가 있을 때
    - 더해라 라는 명령어가 수행할 연산을 `연산 코드` 라고 한다
    - 100과 120처럼 연산에 사용할 데이터나 데이터가 저장된 위치를 `오퍼랜드` 라고 한다
    - 연산 코드는 다시 `연산자`, `피연산자` 라고도 한다
    - 위처럼 연산 코드가 담기는 영역을 `연산 코드 필드` 라고 부르고, 오퍼랜드가 담기는 영역을 `오퍼랜드 필드` 라고 부른다
  - 기계어와 어셈블리어 또한 명령어이기 때문에 연산 코드와 오퍼랜드로 구성되어 있다
- 오퍼랜드 필드는 연산에 사용할 값도 담기지만, 값이 담긴 주소가 담기기도 한다
  - 보통은 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다
  - 그래서 오퍼랜드 필드는 `주소 필드` 라고도 불리운다
- 오퍼랜드 필드는 없을 수도 있다
- 오퍼랜드 필드의 개수에 따라 해당 명령어를 `n-주소 명령어` 라고 부른다
  - 오퍼랜드 필드가 0개면 0-주소 명령어, 오퍼랜드 필드가 두 개면 2-주소 명령어 라고 한단다
- 명령어는 길이 제한이 존재하기 때문에, 연산 코드와 오퍼랜드가 적절히 영역을 나눠 써야한다…
  - 가령 명령어 길이가 16비트이며 연산 코드가 4비트라면, 오퍼랜드의 전체 크기는 12비트가 되는 셈이다
- 연산 코드는 크게 네 가지 유형으로 나뉜다
  - 데이터 전송
    - MOVE: 데이터를 옮겨라
    - STORE: 메모리에 저장하라
    - LOAD(FETCH): 메모리에서 CPU 로 데이터를 가져와라
    - PUSH: 스택에 데이터를 저장하라
    - POP: 스택의 최상단 데이터를 가져와라
  - 산술/논리 연산
    - ADD / SUBJECT / MULTIPLY / DIVIDE: 사칙연산
    - INCREMENT / DECREMENT: 오퍼랜드에 1을 더하라/빼라
    - AND / OR / NOT: AND / OR / NOT: 논리연산
    - COMPARE: 숫자를 비교하여 TRUE/FALSE 를 반환하라
  - 제어 흐름 변경
    - JUMP: 특정 주소로 실행 순서를 옮겨라
    - CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
    - HALT: 프로그램의 실행을 멈춰라
    - CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    - RETURN: CALL 을 호출할 때 저장했던 주소로 돌아가라
      - CALL 과 RETURN 은 프로그램 명령어를 실행하고 return 후 다시 실행 지점으로 돌아가 코드 라인을 실행하는 그 메커니즘이다!!
  - 입출력 제어
    - READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라
    - WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
    - START IO: 입출력 장치를 시작하라
    - TEST IO: 입출력 장치의 상태를 확인하라
- 연산 코드는 CPU 마다 다르다!
- 명령어의 길이 때문에 오퍼랜드에는 데이터를 직접 담는 경우보다 데이터가 저장된 주소를 담는다고 한다
  - CPU 가 한 번에 처리할 수 있는 워드의 길이가 정해져 있기 때문에, 하나의 명령어에 담기는 오퍼랜드 필드가 제한되기 때문이
  - 가령, 데이터 자체의 크기가 크다면 오퍼랜드 필드의 크기도 커야하기 때문에, 한 가지의 오퍼랜드 필드만 가질 수 있게 된다
  - 데이터를 직접 저장하지 않고 참조하여 저장한다면, 한 개의 명령어에 여러 개의 오퍼랜드 필드를 가지고 있을 수 있기 때문에, 주로 오퍼랜드 필드에는 주소가 저장되어 있다고 한다
- 오퍼랜드 필드에 저장된 주소, 즉 실제 연산의 대상이 되는 데이터가 저장된 위치를 `유효 주소` 라고 한다
- 유효 주소를 찾는 방법을 `주소 지정 방식` 이라고 한다
- `즉시 주소 지정 방식(Immediate Addressing Mode)` 은 데이터 자체를 오퍼랜드 필드에 직접 명시하는 방식이다!
  - 하지만, 위에서 정리했듯, 데이터가 크다면 오퍼랜드 필드 개수에 재한이 존재한다
    - 명령어의 크기는.. 바이트 단위가 아니라 비트 단위이기 때문에, 명령어보다 큰 데이터는 애초에 저장 불가능하다
  - 다만, 데이터 자체를 오퍼랜드 필드에 저장하였기 때문에 레지스터나 메모리를 탐색하는 시간이 없어 매우 빠르다!
- `직접 주소 지정 방식(Direct Addressing Mode)` 이란 유효 주소를 직접 명시하는 방식이라고 한다
  - 즉시 주소 지정 방식보단 더 많은 데이터를 표현할 수 있다는 장점이 있다
  - 유효 주소가 가리키는 데이터는 실제 연산에 필요한 데이터이기 때문에 데이터 표현 범위에 대한 한계도 존재한다
  - 또한, 연산 코드의 비트 수를 제외한 공간만 오퍼랜드 필드로 활용할 수 있다는 제약도 여전히 존재한다
- `간접 주소 지정 방식(Indirect Addressing Mode)` 이란 유효 주소의 주소를 오퍼랜드 필드에 저장한다
  - 직접 주소 지정 방식과 비슷한 장단점을 공유한다
  - 다만, 유효 주소의 주소를 저장하기 때문에 직접 주소 지정 방식보다는 좀 더 넓은 범위의 데이터를 표현할 수 있다
    - 유효 주소 자체의 크기가 크다면, 이를 저장할 공간을 충분히 확보할 수 있기 때문
  - 다만, 두 번의 메모리 접근이 필요하기 때문에 제일 느리다
- `레지스터 주소 지정 방식(Register Addressing Mode)` 란 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터가 저장된 레지스터를 오퍼랜드 필드에 직접 명시하는 방법이다
  - CPU 가 메모리에 접근하는 것 보다 레지스터에 접근하는 것이 훨씬 빠르기 때문에, 직접 주소 지정 방식보다 속도가 빠르다
  - 방식 자체는 비슷하나, 속도는 월등히 빠르다
- `레지스터 간접 주소 지정 방식(Register Indirect Addressing Mode)` 이란 아래 구조에서 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법이다
  - 연산에 사용할 데이터(메모리) → 유효 주소를 가진 레지스터 → 유효 주소를 저장한 레지스터
